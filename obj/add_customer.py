# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_auth_info____add_customer__auth_info___(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module add_customer - based on the path /auth_info___. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__login___','__password___',)

  _yang_name = 'auth_info___'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__login___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    self.__password___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['auth_info___']

  def _get_login___(self):
    """
    Getter method for login___, mapped from YANG variable /auth_info___/login___ (data)
    """
    return self.__login___
      
  def _set_login___(self, v, load=False):
    """
    Setter method for login___, mapped from YANG variable /auth_info___/login___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_login___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_login___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="login___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """login___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__login___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_login___(self):
    self.__login___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="login___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)


  def _get_password___(self):
    """
    Getter method for password___, mapped from YANG variable /auth_info___/password___ (data)
    """
    return self.__password___
      
  def _set_password___(self, v, load=False):
    """
    Setter method for password___, mapped from YANG variable /auth_info___/password___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_password___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_password___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="password___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """password___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__password___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_password___(self):
    self.__password___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="password___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)

  login___ = __builtin__.property(_get_login___, _set_login___)
  password___ = __builtin__.property(_get_password___, _set_password___)


  _pyangbind_elements = OrderedDict([('login___', login___), ('password___', password___), ])


class yc_customer_info____add_customer__params____customer_info___(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module add_customer - based on the path /params___/customer_info___. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name___','__iso_4217___','__i_traffic_profile___','__email___',)

  _yang_name = 'customer_info___'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    self.__iso_4217___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iso_4217___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    self.__i_traffic_profile___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="i_traffic_profile___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    self.__email___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="email___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['params___', 'customer_info___']

  def _get_name___(self):
    """
    Getter method for name___, mapped from YANG variable /params___/customer_info___/name___ (data)
    """
    return self.__name___
      
  def _set_name___(self, v, load=False):
    """
    Setter method for name___, mapped from YANG variable /params___/customer_info___/name___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__name___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name___(self):
    self.__name___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)


  def _get_iso_4217___(self):
    """
    Getter method for iso_4217___, mapped from YANG variable /params___/customer_info___/iso_4217___ (data)
    """
    return self.__iso_4217___
      
  def _set_iso_4217___(self, v, load=False):
    """
    Setter method for iso_4217___, mapped from YANG variable /params___/customer_info___/iso_4217___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_iso_4217___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_iso_4217___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="iso_4217___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """iso_4217___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iso_4217___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__iso_4217___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_iso_4217___(self):
    self.__iso_4217___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="iso_4217___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)


  def _get_i_traffic_profile___(self):
    """
    Getter method for i_traffic_profile___, mapped from YANG variable /params___/customer_info___/i_traffic_profile___ (data)
    """
    return self.__i_traffic_profile___
      
  def _set_i_traffic_profile___(self, v, load=False):
    """
    Setter method for i_traffic_profile___, mapped from YANG variable /params___/customer_info___/i_traffic_profile___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_i_traffic_profile___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_i_traffic_profile___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="i_traffic_profile___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """i_traffic_profile___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="i_traffic_profile___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__i_traffic_profile___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_i_traffic_profile___(self):
    self.__i_traffic_profile___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="i_traffic_profile___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)


  def _get_email___(self):
    """
    Getter method for email___, mapped from YANG variable /params___/customer_info___/email___ (data)
    """
    return self.__email___
      
  def _set_email___(self, v, load=False):
    """
    Setter method for email___, mapped from YANG variable /params___/customer_info___/email___ (data)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_email___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_email___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="email___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """email___ must be of a type compatible with data""",
          'defined-type': "add_customer:data",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="email___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)""",
        })

    self.__email___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_email___(self):
    self.__email___ = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="email___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='data', is_config=True)

  name___ = __builtin__.property(_get_name___, _set_name___)
  iso_4217___ = __builtin__.property(_get_iso_4217___, _set_iso_4217___)
  i_traffic_profile___ = __builtin__.property(_get_i_traffic_profile___, _set_i_traffic_profile___)
  email___ = __builtin__.property(_get_email___, _set_email___)


  _pyangbind_elements = OrderedDict([('name___', name___), ('iso_4217___', iso_4217___), ('i_traffic_profile___', i_traffic_profile___), ('email___', email___), ])


class yc_params____add_customer__params___(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module add_customer - based on the path /params___. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__customer_info___',)

  _yang_name = 'params___'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__customer_info___ = YANGDynClass(base=yc_customer_info____add_customer__params____customer_info___, is_container='container', yang_name="customer_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['params___']

  def _get_customer_info___(self):
    """
    Getter method for customer_info___, mapped from YANG variable /params___/customer_info___ (container)
    """
    return self.__customer_info___
      
  def _set_customer_info___(self, v, load=False):
    """
    Setter method for customer_info___, mapped from YANG variable /params___/customer_info___ (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_customer_info___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_customer_info___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_customer_info____add_customer__params____customer_info___, is_container='container', yang_name="customer_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """customer_info___ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_customer_info____add_customer__params____customer_info___, is_container='container', yang_name="customer_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)""",
        })

    self.__customer_info___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_customer_info___(self):
    self.__customer_info___ = YANGDynClass(base=yc_customer_info____add_customer__params____customer_info___, is_container='container', yang_name="customer_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)

  customer_info___ = __builtin__.property(_get_customer_info___, _set_customer_info___)


  _pyangbind_elements = OrderedDict([('customer_info___', customer_info___), ])


class add_customer(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module add_customer - based on the path /add_customer. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__auth_info___','__params___',)

  _yang_name = 'add_customer'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__auth_info___ = YANGDynClass(base=yc_auth_info____add_customer__auth_info___, is_container='container', yang_name="auth_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)
    self.__params___ = YANGDynClass(base=yc_params____add_customer__params___, is_container='container', yang_name="params___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_auth_info___(self):
    """
    Getter method for auth_info___, mapped from YANG variable /auth_info___ (container)
    """
    return self.__auth_info___
      
  def _set_auth_info___(self, v, load=False):
    """
    Setter method for auth_info___, mapped from YANG variable /auth_info___ (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auth_info___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auth_info___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_auth_info____add_customer__auth_info___, is_container='container', yang_name="auth_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """auth_info___ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_auth_info____add_customer__auth_info___, is_container='container', yang_name="auth_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)""",
        })

    self.__auth_info___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_auth_info___(self):
    self.__auth_info___ = YANGDynClass(base=yc_auth_info____add_customer__auth_info___, is_container='container', yang_name="auth_info___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)


  def _get_params___(self):
    """
    Getter method for params___, mapped from YANG variable /params___ (container)
    """
    return self.__params___
      
  def _set_params___(self, v, load=False):
    """
    Setter method for params___, mapped from YANG variable /params___ (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_params___ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_params___() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_params____add_customer__params___, is_container='container', yang_name="params___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """params___ must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_params____add_customer__params___, is_container='container', yang_name="params___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)""",
        })

    self.__params___ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_params___(self):
    self.__params___ = YANGDynClass(base=yc_params____add_customer__params___, is_container='container', yang_name="params___", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://readthedocs.org/projects/hulkbuster/', defining_module='add_customer', yang_type='container', is_config=True)

  auth_info___ = __builtin__.property(_get_auth_info___, _set_auth_info___)
  params___ = __builtin__.property(_get_params___, _set_params___)


  _pyangbind_elements = OrderedDict([('auth_info___', auth_info___), ('params___', params___), ])


